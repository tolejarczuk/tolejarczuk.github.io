<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis as a cache between rabbitmq log stream and postgresql sync | My Digital Garden</title>
<meta name=keywords content><meta name=description content="Integrating Redis as a Cache for RabbitMQ Log Streaming to PostgreSQL 1. Summary This document details the implementation of Redis as a cache layer between RabbitMQ log streaming and PostgreSQL log storage within the Teamium project. Redis, a high-performance in-memory data store, is used to buffer log messages received from RabbitMQ before they are asynchronously synchronized with the PostgreSQL database. This approach improves the system&rsquo;s overall performance, reduces the load on the database, and ensures more efficient log handling."><meta name=author content="Tomasz Olejarczuk"><link rel=canonical href=https://tolejarczuk.github.io/posts/school/semester-4/teamium-project/sprint-4/integrating-redis-as-a-cache-for-rabbitmq-log-streaming-to-postgresql/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://tolejarczuk.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tolejarczuk.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tolejarczuk.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tolejarczuk.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tolejarczuk.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tolejarczuk.github.io/posts/school/semester-4/teamium-project/sprint-4/integrating-redis-as-a-cache-for-rabbitmq-log-streaming-to-postgresql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redis as a cache between rabbitmq log stream and postgresql sync"><meta property="og:description" content="Integrating Redis as a Cache for RabbitMQ Log Streaming to PostgreSQL 1. Summary This document details the implementation of Redis as a cache layer between RabbitMQ log streaming and PostgreSQL log storage within the Teamium project. Redis, a high-performance in-memory data store, is used to buffer log messages received from RabbitMQ before they are asynchronously synchronized with the PostgreSQL database. This approach improves the system&rsquo;s overall performance, reduces the load on the database, and ensures more efficient log handling."><meta property="og:type" content="article"><meta property="og:url" content="https://tolejarczuk.github.io/posts/school/semester-4/teamium-project/sprint-4/integrating-redis-as-a-cache-for-rabbitmq-log-streaming-to-postgresql/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis as a cache between rabbitmq log stream and postgresql sync"><meta name=twitter:description content="Integrating Redis as a Cache for RabbitMQ Log Streaming to PostgreSQL 1. Summary This document details the implementation of Redis as a cache layer between RabbitMQ log streaming and PostgreSQL log storage within the Teamium project. Redis, a high-performance in-memory data store, is used to buffer log messages received from RabbitMQ before they are asynchronously synchronized with the PostgreSQL database. This approach improves the system&rsquo;s overall performance, reduces the load on the database, and ensures more efficient log handling."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tolejarczuk.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis as a cache between rabbitmq log stream and postgresql sync","item":"https://tolejarczuk.github.io/posts/school/semester-4/teamium-project/sprint-4/integrating-redis-as-a-cache-for-rabbitmq-log-streaming-to-postgresql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis as a cache between rabbitmq log stream and postgresql sync","name":"Redis as a cache between rabbitmq log stream and postgresql sync","description":"Integrating Redis as a Cache for RabbitMQ Log Streaming to PostgreSQL 1. Summary This document details the implementation of Redis as a cache layer between RabbitMQ log streaming and PostgreSQL log storage within the Teamium project. Redis, a high-performance in-memory data store, is used to buffer log messages received from RabbitMQ before they are asynchronously synchronized with the PostgreSQL database. This approach improves the system\u0026rsquo;s overall performance, reduces the load on the database, and ensures more efficient log handling.","keywords":[],"articleBody":"Integrating Redis as a Cache for RabbitMQ Log Streaming to PostgreSQL 1. Summary This document details the implementation of Redis as a cache layer between RabbitMQ log streaming and PostgreSQL log storage within the Teamium project. Redis, a high-performance in-memory data store, is used to buffer log messages received from RabbitMQ before they are asynchronously synchronized with the PostgreSQL database. This approach improves the system’s overall performance, reduces the load on the database, and ensures more efficient log handling.\n2. Introduction 2.1. Background The Teamium project utilizes RabbitMQ to transmit log messages generated by the MATLAB server in real time. These logs are then consumed by the API wrapper and stored in a PostgreSQL database. While this architecture works well, it can lead to performance bottlenecks when the volume of log messages is high, as direct writes to the database can become a limiting factor.\nTo address this, Redis is introduced as a cache. Log messages are first published to RabbitMQ, then consumed by the API wrapper and stored in Redis. A background service periodically reads these messages from Redis and writes them to PostgreSQL, effectively offloading the database and improving overall system responsiveness.\n2.2. Objectives The primary objectives of integrating Redis as a cache are:\nPerformance Optimization: Improve the system’s ability to handle a high volume of log messages by reducing the frequency of database writes. Database Load Reduction: Decrease the load on the PostgreSQL database, allowing it to focus on other critical tasks. Fault Tolerance: Provide a buffer for log messages in case the PostgreSQL database is temporarily unavailable. 3. Methodology 3.1. Architecture The revised architecture incorporates Redis as a cache between RabbitMQ and PostgreSQL:\nMATLAB Logging: Log messages are published to a RabbitMQ exchange. RabbitMQ Routing: The exchange routes messages to a queue. API Wrapper Consumption and Caching: The API wrapper consumes messages from the queue and stores them in Redis. Redis-PostgreSQL Synchronization: A background service periodically reads messages from Redis and writes them to PostgreSQL. 3.2. Implementation Redis Configuration: The Docker Compose file was updated to include a Redis container. A Redis client library (StackExchange.Redis) was added to the C# API wrapper project. API Wrapper (MessageBusSubscriber): Modified to store received log messages in Redis using a list data structure. Redis-PostgreSQL Sync Service (RedisPostgresSyncService): Implements a background service that runs periodically (e.g., every minute). Retrieves log messages from Redis in batches. Writes the retrieved messages to the PostgreSQL database using Entity Framework Core. Deletes the processed messages from Redis to prevent duplication. 4. Results \u0026 Insights 4.1. Key Outcomes Improved Performance: The introduction of Redis as a cache significantly improved the system’s ability to handle a high volume of log messages. The API wrapper can quickly store messages in Redis without waiting for database writes, leading to faster response times and reduced latency. Reduced Database Load: By batching log writes to PostgreSQL, the load on the database was reduced, freeing up resources for other operations and improving overall system performance. Reliable Log Persistence: The asynchronous synchronization mechanism ensures that log messages are reliably persisted to PostgreSQL, even if there are temporary network issues or database unavailability. 5. Insights and Conclusion The integration of Redis as a cache for RabbitMQ log streaming has proven to be a highly effective solution for optimizing log handling in the Teamium project. By decoupling log ingestion from database writes, we have achieved a more scalable, resilient, and performant system. This enhancement not only addresses current performance bottlenecks but also lays the groundwork for future expansion and the ability to handle even larger volumes of log data.\nThe success of this integration highlights the importance of carefully considering caching strategies in distributed systems, especially when dealing with high-throughput data streams. By choosing the right tools and implementing them thoughtfully, we can significantly improve system performance and ensure a seamless user experience.\nLast Modified: =dateformat(this.file.mtime, \"DDDD, HH:mm\")\nTags: =this.file.tags\nList FROM #kubernetes ","wordCount":"648","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Tomasz Olejarczuk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tolejarczuk.github.io/posts/school/semester-4/teamium-project/sprint-4/integrating-redis-as-a-cache-for-rabbitmq-log-streaming-to-postgresql/"},"publisher":{"@type":"Organization","name":"My Digital Garden","logo":{"@type":"ImageObject","url":"https://tolejarczuk.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tolejarczuk.github.io/ accesskey=h title="My Digital Garden (Alt + H)">My Digital Garden</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Redis as a cache between rabbitmq log stream and postgresql sync</h1><div class=post-meta>Tomasz Olejarczuk</div></header><div class=post-content><h1 id=integrating-redis-as-a-cache-for-rabbitmq-log-streaming-to-postgresql>Integrating Redis as a Cache for RabbitMQ Log Streaming to PostgreSQL<a hidden class=anchor aria-hidden=true href=#integrating-redis-as-a-cache-for-rabbitmq-log-streaming-to-postgresql>#</a></h1><h1 id=1-summary>1. Summary<a hidden class=anchor aria-hidden=true href=#1-summary>#</a></h1><p>This document details the implementation of Redis as a cache layer between RabbitMQ log streaming and PostgreSQL log storage within the Teamium project. Redis, a high-performance in-memory data store, is used to buffer log messages received from RabbitMQ before they are asynchronously synchronized with the PostgreSQL database. This approach improves the system&rsquo;s overall performance, reduces the load on the database, and ensures more efficient log handling.</p><h1 id=2-introduction>2. Introduction<a hidden class=anchor aria-hidden=true href=#2-introduction>#</a></h1><h2 id=21-background>2.1. Background<a hidden class=anchor aria-hidden=true href=#21-background>#</a></h2><p>The Teamium project utilizes RabbitMQ to transmit log messages generated by the MATLAB server in real time. These logs are then consumed by the API wrapper and stored in a PostgreSQL database. While this architecture works well, it can lead to performance bottlenecks when the volume of log messages is high, as direct writes to the database can become a limiting factor.</p><p>To address this, Redis is introduced as a cache. Log messages are first published to RabbitMQ, then consumed by the API wrapper and stored in Redis. A background service periodically reads these messages from Redis and writes them to PostgreSQL, effectively offloading the database and improving overall system responsiveness.</p><h2 id=22-objectives>2.2. Objectives<a hidden class=anchor aria-hidden=true href=#22-objectives>#</a></h2><p>The primary objectives of integrating Redis as a cache are:</p><ol><li><strong>Performance Optimization:</strong> Improve the system&rsquo;s ability to handle a high volume of log messages by reducing the frequency of database writes.</li><li><strong>Database Load Reduction:</strong> Decrease the load on the PostgreSQL database, allowing it to focus on other critical tasks.</li><li><strong>Fault Tolerance:</strong> Provide a buffer for log messages in case the PostgreSQL database is temporarily unavailable.</li></ol><h1 id=3-methodology>3. Methodology<a hidden class=anchor aria-hidden=true href=#3-methodology>#</a></h1><h2 id=31-architecture>3.1. Architecture<a hidden class=anchor aria-hidden=true href=#31-architecture>#</a></h2><p>The revised architecture incorporates Redis as a cache between RabbitMQ and PostgreSQL:</p><ol><li><strong>MATLAB Logging:</strong> Log messages are published to a RabbitMQ exchange.</li><li><strong>RabbitMQ Routing:</strong> The exchange routes messages to a queue.</li><li><strong>API Wrapper Consumption and Caching:</strong> The API wrapper consumes messages from the queue and stores them in Redis.</li><li><strong>Redis-PostgreSQL Synchronization:</strong> A background service periodically reads messages from Redis and writes them to PostgreSQL.</li></ol><p><img src=/posts/School/Semester%204/Teamium%20project/Sprint%204/Bins/Images/api_wrapper.png></p><h2 id=32-implementation>3.2. Implementation<a hidden class=anchor aria-hidden=true href=#32-implementation>#</a></h2><ul><li><strong>Redis Configuration:</strong><ul><li>The Docker Compose file was updated to include a Redis container.</li><li>A Redis client library (StackExchange.Redis) was added to the C# API wrapper project.</li></ul></li><li><strong>API Wrapper (MessageBusSubscriber):</strong><ul><li>Modified to store received log messages in Redis using a list data structure.</li></ul></li><li><strong>Redis-PostgreSQL Sync Service (<code>RedisPostgresSyncService</code>):</strong><ul><li>Implements a background service that runs periodically (e.g., every minute).</li><li>Retrieves log messages from Redis in batches.</li><li>Writes the retrieved messages to the PostgreSQL database using Entity Framework Core.</li><li>Deletes the processed messages from Redis to prevent duplication.</li></ul></li></ul><h1 id=4-results--insights>4. Results & Insights<a hidden class=anchor aria-hidden=true href=#4-results--insights>#</a></h1><h2 id=41-key-outcomes>4.1. Key Outcomes<a hidden class=anchor aria-hidden=true href=#41-key-outcomes>#</a></h2><ul><li><strong>Improved Performance:</strong> The introduction of Redis as a cache significantly improved the system&rsquo;s ability to handle a high volume of log messages. The API wrapper can quickly store messages in Redis without waiting for database writes, leading to faster response times and reduced latency.</li><li><strong>Reduced Database Load:</strong> By batching log writes to PostgreSQL, the load on the database was reduced, freeing up resources for other operations and improving overall system performance.</li><li><strong>Reliable Log Persistence:</strong> The asynchronous synchronization mechanism ensures that log messages are reliably persisted to PostgreSQL, even if there are temporary network issues or database unavailability.</li></ul><h1 id=5-insights-and-conclusion>5. Insights and Conclusion<a hidden class=anchor aria-hidden=true href=#5-insights-and-conclusion>#</a></h1><p>The integration of Redis as a cache for RabbitMQ log streaming has proven to be a highly effective solution for optimizing log handling in the Teamium project. By decoupling log ingestion from database writes, we have achieved a more scalable, resilient, and performant system. This enhancement not only addresses current performance bottlenecks but also lays the groundwork for future expansion and the ability to handle even larger volumes of log data.</p><p>The success of this integration highlights the importance of carefully considering caching strategies in distributed systems, especially when dealing with high-throughput data streams. By choosing the right tools and implementing them thoughtfully, we can significantly improve system performance and ensure a seamless user experience.</p><hr><p>Last Modified: <code>=dateformat(this.file.mtime, "DDDD, HH:mm")</code></p><h4 id=tags>Tags:<a hidden class=anchor aria-hidden=true href=#tags>#</a></h4><p><code>=this.file.tags</code></p><pre tabindex=0><code class=language-dataview data-lang=dataview>List FROM #kubernetes
</code></pre></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tolejarczuk.github.io/>My Digital Garden</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>